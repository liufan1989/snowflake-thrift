// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
// the file is edited by liufan 
//由于io复用，单线程处理，所以不做多线程加锁考虑!

#include "Snowflake.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TNonblockingServer.h>
#include <sys/time.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdarg.h>

#define BUILDTIME ("buildtime:"__DATE__" "__TIME__"\n")

#ifndef timeradd
#define timeradd(tvp, uvp, vvp)                 \
    do {                                        \
        (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;      \
        (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;   \
        if ((vvp)->tv_usec >= 1000000L) {        \
            (vvp)->tv_sec++;                    \
            (vvp)->tv_usec -= 1000000L;          \
        }                                       \
    } while (0)
#endif

#ifndef timercmp
#define timercmp(tvp, uvp, cmp)                 \
    (((tvp)->tv_sec == (uvp)->tv_sec) ?         \
    ((tvp)->tv_usec cmp (uvp)->tv_usec) :       \
    ((tvp)->tv_sec cmp (uvp)->tv_sec))
#endif

#ifndef timernow
#define timernow(msec)                 \
    do {                                 \
      struct timeval now;                \
      gettimeofday(&now,NULL);            \
      msec = now.tv_sec * 1000L + now.tv_usec / 1000L; \
    } while (0)
#endif

#define LOG_NAME "/var/log/snowflake.log"
#define LOG_MAX_SIZE 10485760	//1024*1024*10
#define LOCK_FILE    "/var/run/snowflake.pid"
#define LOCK_FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)

using namespace::apache::thrift;
using namespace::apache::thrift::protocol;
using namespace::apache::thrift::transport;
using namespace::apache::thrift::server;
using namespace::apache::thrift::concurrency;

int g_port = 7777;
int g_station_id = 1;
int g_process_id = 1;
int g_log_index = 0;
FILE *g_log_fp = NULL;
char g_log_name[32] = LOG_NAME;
int g_show_help = 0;

void log_init()
{
	g_log_fp = fopen(g_log_name, "a+");
	if (g_log_fp == NULL) {
		printf("snow flake log init fail!\n");
		exit(-1);
	}
	return;
}

void log_print(const char *fmt, ...)
{
	char buf[32];
	int filesize = ftell(g_log_fp);
	if (filesize >= LOG_MAX_SIZE) {
		fclose(g_log_fp);
		sprintf(buf, "%s.%d", LOG_NAME, g_log_index);
		g_log_index++;
		rename(g_log_name, buf);
		g_log_fp = fopen(g_log_name, "a+");
	}
	time_t t;
	struct tm *lt;
	t = time(NULL);
	lt = localtime(&t);
	strftime(buf, 32, "%Y-%m-%d %H:%M:%S", lt);
	fprintf(g_log_fp, "[%s]", buf);
	va_list argptr;
	va_start(argptr, fmt);
	vfprintf(g_log_fp, fmt, argptr);
	va_end(argptr);
	fprintf(g_log_fp, "\n");
    fflush(g_log_fp);
}

void log_close()
{
	fclose(g_log_fp);
}

const int64_t station_id_bits = 5L;
const int64_t process_id_bits = 5L;
const int64_t sequence_id_bits = 12L;

const int64_t max_station_id = -1L ^ (-1L << station_id_bits);
const int64_t max_process_id = -1L ^ (-1L << process_id_bits);
const int64_t sequence_mask = -1L ^ (-1L << sequence_id_bits);

const int64_t station_id_shift = sequence_id_bits;
const int64_t process_id_shift = sequence_id_bits + station_id_bits;
const int64_t timestamp_shift =
    sequence_id_bits + station_id_bits + process_id_bits;
const int64_t twepoch = 1460563200000L;

using boost::shared_ptr;

class SnowflakeHandler:virtual public SnowflakeIf {
 public:
	SnowflakeHandler(int64_t station_id, int64_t process_id) {
		if (station_id > max_station_id || process_id > max_process_id) {
			throw "station id is too max or process id is too max!";
		}
		m_station_id = station_id;
		m_process_id = process_id;
		m_sequence_id = 0L;
		m_last_time = -1L;

		nap_val.tv_sec = 0;
		nap_val.tv_usec = 1000;
		nap_spec.tv_sec = 0;
		nap_spec.tv_nsec = 1000000;
	}

	int64_t get_station_id() {
		log_print("%s:%ld", "get_station_id", m_station_id);
		return m_station_id;
	}

	int64_t get_process_id() {
		log_print("%s:%ld", "get_process_id", m_process_id);
		return m_process_id;
	}

	int64_t get_timestamp() {
		int64_t current_time;
		timernow(current_time);
		log_print("%s:%ld", "get_timestamp", current_time);
		return current_time;
	}

	int64_t get_id(const std::string & useragent) {
		int64_t id;
		int64_t present_time;
		timernow(present_time);
		if (m_last_time > present_time) {
			log_print("%s %ld",
				  "clock is moving backwards. Rejecting request until",
				  m_last_time);
			return -1L;
		}
		if (m_last_time == present_time) {
			m_sequence_id = (m_sequence_id + 1L) & sequence_mask;
			if (m_sequence_id == 0L)
				//present_time = till_next_millis_by_gettimeofday();
				//present_time = till_next_millis_by_nonsleep();
				present_time = till_next_millis();
		} else {
			m_sequence_id = 0L;
		}
		m_last_time = present_time;
		id = ((present_time -
		       twepoch) << timestamp_shift) | (m_station_id <<
						       station_id_shift) |
		    (m_process_id << process_id_shift) | m_sequence_id;
		log_print("%s:%ld", useragent.c_str(), id);
		return id;
	}

 protected:

	inline int64_t till_next_millis_by_gettimeofday() {
		int64_t msec;
		struct timeval now, sleep_until;
		gettimeofday(&now, NULL);
		timeradd(&now, &nap_val, &sleep_until);
		do {
			gettimeofday(&now, NULL);
		} while (timercmp(&now, &sleep_until, <));
		msec = now.tv_sec * 1000L + now.tv_usec / 1000L;
		return msec;
	}

	inline int64_t till_next_millis_by_nonsleep() {
		int64_t msec;
		struct timeval now;
		nanosleep(&nap_spec, NULL);
		gettimeofday(&now, NULL);
		msec = now.tv_sec * 1000L + now.tv_usec / 1000L;
		return msec;
	}

	inline int64_t till_next_millis() {
		int64_t msec;
		struct timeval now_msec;
		timernow(msec);
		while (msec <= m_last_time) {
			gettimeofday(&now_msec, NULL);
			msec =
			    now_msec.tv_sec * 1000L + now_msec.tv_usec / 1000L;
		}
		return msec;
	}

 protected:
	struct timeval nap_val;
	struct timespec nap_spec;
	int64_t m_station_id;
	int64_t m_process_id;
	int64_t m_sequence_id;
	int64_t m_last_time;

};

int parse_args(int argc, char **argv)
{
	int i;
	for (i = 1; i < argc; ++i) {
		if (0 == strcmp("-p", argv[i])) {
			g_port = atoi(argv[++i]);
			if (g_port > 65535 || g_port < 1024)
				return -1;
		} else if (0 == strcmp("-o", argv[i])) {
			strcpy(g_log_name, argv[++i]);
		} else if (0 == strcmp("-d", argv[i])) {
			g_station_id = atoi(argv[++i]);
			if (g_station_id > max_station_id || g_station_id < 0)
				return -1;
		} else if (0 == strcmp("-w", argv[i])) {
			g_process_id = atoi(argv[++i]);
			if (g_process_id > max_process_id || g_process_id < 0)
				return -1;
		} else if (0 == strcmp("-h", argv[i])) {
			g_show_help = 1;
		} else {
			return -1;
		}
	}
	return 0;
}

void show_help()
{
	printf("-------------------------------------------------------\n");
	printf("Useage: snowflake -s xxx -p xxx -p xxx -o snowflake.log\n");
	printf("        -d Station ID [0~%ld]\n", max_station_id);
	printf("        -w Process ID [0~%ld]\n", max_process_id);
	printf("        -p Port          default Port 7777\n");
	printf("        -o Log File Name default /var/log/snowflake.log\n");
	printf("        -h Show Help\n");
	printf("        Snowflake is Developed by LiuFan!\n");
	printf(BUILDTIME);
	printf("-------------------------------------------------------\n");
}

void init_daemon(void)
{
	pid_t pid;
	int fd, fdTableSize;
	signal(SIGCHLD, SIG_IGN);
	if (pid = fork())
		exit(0);
	else if (pid < 0)
		exit(1);
	setsid();
	if (pid = fork())
		exit(0);
	else if (pid < 0)
		exit(1);
	fdTableSize = getdtablesize();
	for (fd = 0; fd < fdTableSize; fd++)
		close(fd);
	umask(0);
	return;
}

int running(void)
{
	int fdLockFile;
	char szPid[32];
	struct flock fl;
	fdLockFile = open(LOCK_FILE, O_RDWR | O_CREAT, LOCK_FILE_MODE);
	if (fdLockFile < 0) {
		exit(-1);
	}
	fl.l_type = F_WRLCK;
	fl.l_whence = SEEK_SET;
	fl.l_start = 0;
	fl.l_len = 0;
	if (fcntl(fdLockFile, F_SETLK, &fl) < 0) {
		if (EACCES == errno || EAGAIN == errno) {
			close(fdLockFile);
			return 1;
		}
		exit(-1);
	}
	ftruncate(fdLockFile, 0);
	sprintf(szPid, "%ld", (int64_t) getpid());
	write(fdLockFile, szPid, strlen(szPid) + 1);
	return 0;
}

void SignHandler(int iSignNo)
{
	log_print("%s", "snowflaked catch SIGKILL!");
	log_close();
}

int main(int argc, char **argv)
{
	int ret = 0;
	ret = parse_args(argc, argv);
	if (ret == -1) {
		show_help();
		return -1;
	}
	if (g_show_help) {
		show_help();
		return 0;
	}
	init_daemon();
	signal(SIGKILL, SignHandler);
	log_init();
	log_print("%s", "snowflake starting .......");
	log_print("%s,%d", "snowflake running port:", g_port);
	shared_ptr < SnowflakeHandler >
	handler(new SnowflakeHandler(g_station_id, g_process_id));
	shared_ptr < TProcessor > processor(new SnowflakeProcessor(handler));
	shared_ptr < TProtocolFactory >
	protocolFactory(new TBinaryProtocolFactory());
	//shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(20);
	//shared_ptr<apache::thrift::concurrency::PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
	//threadManager->threadFactory(threadFactory);
	//threadManager->start();
	TNonblockingServer server(processor, protocolFactory, g_port);
	server.serve();
	return 0;
}
